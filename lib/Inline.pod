=head1 NAME

B<Inline> - Use other programming languages inside Perl scripts and modules.

=head1 SYNOPSIS

    print "9 + 16 = ", add(9, 16), "\n";
    print "9 - 16 = ", subtract(9, 16), "\n";
 
    use Inline C => <<'END_OF_C_CODE';
    
    int add(int x, int y) {
      return x + y;
    }
 
    int subtract(int x, int y) {
      return x - y;
    }
   
    END_OF_C_CODE

=head1 DESCRIPTION

The C<Inline> module allows you to put source code from other programming languages directly "inline" in a Perl script or module. The code is automatically compiled as needed, and then loaded for immediate access from Perl.

C<Inline> saves you from the hassle of having to write and compile your own glue code using facilities like XS or SWIG. Simply type the code where you want it and run your Perl as normal. All the hairy details are handled for you. The compilation and installation of your code chunks all happen transparently; all you will notice is the delay of compilation.

The C<Inline> code only gets compiled the first time you run it (or whenever it is modified) so you only take the performance hit once. Code that is Inlined into distributed modules (like on the CPAN) will get compiled when the module is installed, so the end user will never notice the compilation time.

Best of all, it works the same on both Unix and Microsoft Windows. See L<"SUPPORTED PLATFORMS"> below.

=head2 Why Inline?

Do you want to know "Why would I use other languages in Perl?" or "Why should I use C<Inline> to do it?"? I'll try to answer both.

=over 4

=item Why would I use other languages in Perl?

The most obvious reason is performance. For an interpreted language, Perl is very fast. Many people will say "Anything Perl can do, C can do faster". (They never mention the development time ;-) Anyway, you may be able to remove a bottleneck in your Perl code by using another language, without having to write the entire program in that language. This keeps your overall development time down, because you're using Perl for all of the non-critical code.

Another reason is to access functionality from existing API-s that use the language. Some of this code may only be available in binary form. But by creating small subroutines in the native language, you can "glue" existing libraries to your Perl. As a user of the CPAN, you know that code reuse is a good thing. So why throw away those Fortran libraries just yet?

If you are using Inline with the C language (currently the only way to do it), then you can access the full internals of Perl itself. This opens up the floodgates to both extreme power and peril.

Maybe the best reason is "Because you want to!". Diversity keeps the world interesting. TMTOWTDI!

=item Why should I use C<Inline> to do it?

There are already two major facilities for extending Perl with C. They are XS and SWIG. Now if you're familiar with either, then I may be preaching to the choir. Well, here goes:

 <SERMON>

Greetings congregation. This morning I want to open your eyes to the virtues of B<Inline> and the perils of B<XS>. Let us compare the two.

---

B<Inline -> You can use it from a regular script.

B<XS -> Requires you to create a module and an XS file and a makefile, in addition to your regular script. Actually, the program C<h2xs> does a nice job of getting you started, but that's still a lot of junk to maintain.

---

B<XS -> You need rebuild every time you want to test a small change.

B<Inline -> Perl programmers cannot be bothered with silly things like compiling. "Tweak, Run, Tweak, Run" is our way of life. C<Inline> does all the dirty work for you.

---

B<XS -> There is a difficult learning curve involved with setting up and using the XS environment. (At least for a simple Perl preacher like me.) Read the following perldocs and man pages if you don't believe me:

 * perlxs
 * perlxstut
 * perlapi
 * perlguts
 * perlmod
 * h2xs
 * xsubpp
 * ExtUtils::MakeMaker

B<Inline -> Makes easy things easy, and hard things possible. Just like Perl.

---

B<XS -> Only implements C and C++.

B<Inline -> Plans to implement several languages. For now, C<Inline> only implements C and it uses XS to do it. (Dirty little secret) But this is the right thing to do. See L<"SUPPORTED LANGUAGES"> below. 

---

Amen.

 </SERMON>

=back

=head2 How it works

C<Inline> performs the following steps:

=over 4

=item 1) Receive the Source Code

C<Inline> gets the source code from your script or module with a statement like the following:

 use Inline C => Source-Code;

where C<C> is the programming language of the source code, and C<Source-Code> is a string (most easily represented by using the "Here Document" quoting style; see L<"SYNOPSIS"> above), a file name, an open file handle, or a reference to a subroutine (that will return source code).

Since C<Inline> is coded in a "C<use>" statement, everything is done during Perl's compile time. If anything needs to be done that will affect the C<Source-Code> string, it needs to be done in a C<BEGIN> block that is I<before> the "C<use Inline ...>" statement. This might include setting interpolated variables, or setting options in the C<Inline::Config> module.

=item 2) Check if the Source Code has been Compiled

C<Inline> only needs to compile the source code if it has not yet been compiled. It accomplishes this seemingly magical task in an extremely simple and straightforward manner. It runs the source text through the C<Digest::MD5> module to produce a 128-bit "fingerprint" which is virtually unique. The fingerprint (in hex) is I<mangled> with the current package name (and the script name, if the package is "C<main>") along with the name of the programming language, to form a unique name for the executable module. For instance, the C<C> code from C<examples/example001.pl> (see L<"Examples In C">) would mangle into:

 main_C_example001_pl_3a9a7ba88a8fb10714be625de5e701f1.so

If an executable with that name already exists, then proceed to step 8. (No compilation is necessary)

=item 3) Find a Place to Build and Install

At this point C<Inline> knows it needs to compile the source code. The first thing to figure out is where to create the great big mess associated with compilation, and where to put the object when it's done.

By default C<Inline> will try to build and install under the first one of the following places that is a valid directory and is writable:

     1) $ENV{PERL_INLINE_BLIB}
        (The PERL_INLINE_BLIB environment variable overrides all else)
     2) ./blib_I/  
        (The current directory, unless you're in your home directory)
     3) $bin/blib_I/
        (Where '$bin' is the directory that the script is in)
     4) $ENV{HOME}/blib_I/
        (Under your home directory)
     5) $ENV{HOME}/.blib_I/
	(Same as above but more discrete)

If none of those exist, Inline will attempt to create and use one of following:

     6) $bin/blib_I/ 
     7) ./blib_I/ 

Failing that, Inline will croak. Optionally, you can configure C<Inline> to build and install exactly where you want, using C<Inline::Config>. See L<Inline::Config>.
 
If C<$Inline::Config::SITE_INSTALL=1>, then C<Inline> will only use C<./blib_I/> to build in, and the C<$Config{installsitearch}> directory to install the executable in. This option is intended to be used in modules that are to be distributed on the CPAN, so that they get installed in the proper place.

Optionally, you can configure C<Inline> to build and install exactly where you want. 

B<NOTE>: C<blib> stands for "build library" in Perl-speak. It is a directory that gets created when you install a Perl module on your system. C<blib_I> is the C<Inline.pm> version of the same concept.

=item 4) Parse the Source for Semantic Cues

C<Inline> uses the module C<Parse::RecDescent> to parse through your chunks of source code and look for things that it can create run-time bindings to. For instance, in C<C> it looks for all of the function definitions and breaks them down into names and data types. These elements are used to correctly bind the C<C> function to a C<Perl> subroutine.

=item 5) Create the Build Environment

Now C<Inline> can take all of the gathered information and create an environment to build your source code into an executable. Without going into all the details, it just creates the appropriate directories, creates the appropriate source files including an XS file and a C<Makefile.PL>.

=item 6) Compile the Code and Install the Executable

The planets are in alignment. Now for the easy part. C<Inline> just does what you would do to install a module. "C<perl Makefile.PL && make && make test && make install>". If something goes awry, C<Inline> will croak with a message indicating where to look for more info.

=item 7) Tidy Up

By default, C<Inline> will remove all of the mess created by the build process, assuming that everything worked. If the compile fails, C<Inline> will leave everything intact, so that you can debug your errors. Setting C<$Inline::Config::CLEAN_AFTER_BUILD=0> will also stop C<Inline> from cleaning up.

=item 8) DynaLoad the Executable

C<Inline> uses the C<DynaLoader::bootstrap> method to pull your external module into C<Perl> space. Now you can call all of your external functions like Perl subroutines. Wheeee!

=back

=head2 Another Way To Do It

Instead of specifying the source code as a here-document string, you may want to put it at the end of your script, after the C<__END__> statement. Then you can pass it to C<Inline> using the C<DATA> filehandle, like this:

    use Inline;
    Inline->import(C => <DATA>);
    
    print "9 + 16 = ", add(9, 16), "\n";
    print "9 - 16 = ", subtract(9, 16), "\n";
    
    __END__
    
    int add(int x, int y) {
      return x + y;
    }
    
    int subtract(int x, int y) {
      return x - y;
    }

Since the C<use> command is executed at compile time and the C<DATA> filehandle isn't available until runtime, you'll need to invoke the C<import> call manually. This is a useful idiom anytime you need to specify C<Inline> code at runtime.

=head2 Configuration

C<Inline> trys to do the right thing as often as possible. But sometimes you may need to override the default actions. This is where C<Inline::Config> comes to the rescue. C<Inline::Config> gives you a more fine-grained control over the entire process. The other side of that coin is "you need to know what you are doing". 

An important point to remember is that the config settings must be done I<before> the C<Inline> code is evaluated. Since a "C<use>" happens at (C<Perl>'s) compile time, you may need to something like this:

    BEGIN {
        use Inline;
        $Inline::Config::OPTION_NUMBER_9 = 'Yes';
    # or
        Inline::Config->new->option_number_9('Yes');
    }
    
    use Inline C => "C code goes here...";

See L<Inline::Config> for more info.

=head2 Configuration from the Command Line

C<Inline> lets you set many of the configuration options from the command line. This can be very handy, especially when you only want to set the options temporarily, for say, debugging. 

For instance, to get some general information about your C<Inline> code in the script C<Foo.pl>, use the command:

    perl -MInline=INFO Foo.pl

If you want to force your code to compile, even if its already done, use:

    perl -MInline=FORCE Foo.pl

If you want to do both, use:

    perl -MInline=INFO -MInline=FORCE Foo.pl

or better yet:

    perl -MInline=INFO,FORCE Foo.pl

See L<Inline::Config> for more info.

=head2 Writing Modules with Inline

Writing CPAN modules that use other programming languages is easy with C<Inline>. Let's say that you wanted to write a module called C<Math::Simple> using the previous example code. Start by using the following command:

    h2xs -PAXn Math::Simple

This will generate a bunch of files that form a skeleton of what you need for a distributable module. Next, modify the C<Simple.pm> file to look like this:

    package Math::Simple;
    
    use strict;
    use vars qw($VERSION @ISA @EXPORT_OK);
    require Exporter;
    @ISA = qw(Exporter);
    @EXPORT_OK = qw(add subtract);
    BEGIN {
        $VERSION = '0.01';
    }
    
    use Inline;
    Inline->import(C => <DATA>);
    
    1;
    
    __DATA__
    
    int add(int x, int y) {
      return x + y;
    }
    
    int subtract(int x, int y) {
      return x - y;
    }

Finally, you need to add the following line to the top of your C<test.pl> file:

    use Inline SITE_INSTALL;

When the person installing C<Math::Simple> does a "C<make test>", the C<Inline> module will compile the Inlined code and place the executable code into the C<./blib> directory. Then when a "C<make install>" is done, the module will be copied into Perl's C<$Config{installsitearch}> directory (which is where an installed module should go).

Now all you need to do is:

    perl Makefile.PL
    make dist

That will generate the file C<Math-Simple-0.01.tar.gz> which is a distributable package.

=head2 Fancy Tricks

The C<Inline> module opens up all sorts of possibilities regarding what you can do with C<Perl> and C<C>. Since everything happens at run time (depending on how you think of it) you can generate C<C> code on the fly and effectively 'C<eval>' it. (How this might be useful is left as an exercise to the reader :-) 

Here is how you would code such a beast:

    BEGIN {$c_code = &c_code_generator()}
    use Inline C => $c_code;  # will die if code doesn't compile
    my_function();

or

    $c_code = &c_code_generator();
    eval {use Inline C => $c_code};
    if ($@) {
        handle_error($@);     # trap error if code doesn't compile
    }
    else {
        my_function();
    }

=head1 SUPPORTED LANGUAGES

Currently, "C<C>" is the only supported language. This is obviously the most important language to support. That is because C<Perl> itself is written in C<C>. By giving a your C<Perl> scripts access to C<C>, you in effect give them access to the entire glorious internals of C<Perl>. (Caveat scriptor :-)

C<C> is also the easiest language to implement because the tools needed to do so, (like XS and C<ExtUtils::MakeMaker>) have already been written and are very flexible and reliable. C<Inline> currently makes use of these pre-existing tools.

But there is definitely no reason why C<Inline> must or should stop with C<C>. As long as sensible bindings can be defined between Perl and another language, that language could be a candidate for the C<Inline> module. Current languages I am considering adding support for include:

 - C++
 - Fortran
 - Pascal
 - Python

B<Note:> Since many C<C> compilers allow the use of assembly code within C, you may want to consider Assembly Language as supported. Ready to start scripting out new device drivers?

=head1 SUPPORTED PLATFORMS

This module should work anywhere that CPAN extension modules (those that use XS) can be installed, using the typical install format of:

    perl Makefile.PL
    make
    make test
    make install

It has been tested on many Unix variants and Windows NT.

B<NOTE>: C<Inline.pm> requires Perl 5.005 or higher because C<Parse::RecDescent> requires it. (Something to do with the C<qr> operator)

Inline has been tested on the following platforms:

 V#   OS      OS V#   Perl V# Human              Email 
 0.25 Linux   2.2.13  5.00503 Brian Ingerson     ingy@cpan.org
 0.25 Linux   2.2.13  5.6     Brian Ingerson     ingy@cpan.org
 0.20 FreeBSD 3.4     5.00503 Timothy A Gregory  tgregory@tarjema.com      
 0.20 FreeBSD 4.0     5.00503 Timothy A Gregory  tgregory@tarjema.com      
 0.20 FreeBSD 4.0     5.6     Timothy A Gregory  tgregory@tarjema.com      
 0.20 Linux   2.0.36  5.00503 Prakasa Bellam     pbellam@cobaltgroup.com
 0.20 HPUX    B.10.20 5.00503 Jamie Shaffer      jshaffer@chronology.com
 0.20 SunOS   5.6     5.6.0   Jamie Shaffer      jshaffer@chronology.com
 0.20 SunOS   5.5.1   5.6.0   Jamie Shaffer      jshaffer@chronology.com
 0.22 OpenBSD 2.7     5.6.0   Jeremy Devenport   jeremy@weezel.com
 0.22 FreeBSD 3.1     5.00503 Doug Beaver        dougb@scalar.org
 0.25 WinNT   4.0 sp6 5.00503 Brian Ingerson     ingy@cpan.org
 0.24 Cygwin  1.1.1   5.6.0   Leo Schalkwyk      L.Schalkwyk@iop.kcl.ac.uk

The Microsoft tests deserve a little more explanation. I used the following:

 Windows NT 4.0 (service pack 6)
 Perl 5.005_03 (ActiveState build 522)
 MS Visual C++ 6.0
 The "nmake" make utility (distributed w/ Visual C++)

C<Inline.pm> pulls all of its base configuration (including which C<make> utility to use) from C<config.pm>. Since your MSWin32 version of Perl probably came from ActiveState (as a binary distribution) the C<Config.pm> will indicate that C<nmake> is the system's C<make> utility. That is because ActiveState uses Visual C++ to compile Perl.

To install C<Inline.pm> (or any other CPAN module) on MSWin32 w/ Visual C++, use these:

    perl Makefile.PL
    nmake
    nmake test
    nmake install

The "Cygwin" test was done on a Windows 98 machine using the Cygwin Unix/Win32 porting layer software from Cygnus. The C<perl> binary on this machine was also compiled using the Cygwin tool set (C<gcc>). This software is freely available from http://sources.redhat.com/cygwin/

If C<Inline> works on your platform, please email me the info above. If it doesn't work, see L<BUGS AND DEFICIENCIES> below.

=head1 SEE ALSO

L<Inline::Config> and L<Inline::C::Tutorial>

=head1 BUGS AND DEFICIENCIES

This is B<ALPHA> code. The interface may still change.

When reporting a bug, please do the following:

 - Put "use Inline REPORTBUG;" at the top of your code, or
   use the command line option "perl -MInline=REPORTBUG ...".
 - Run your code.
 - Follow the printed directions.

Here are some things to watch out for:

=over 4

=item 1

The C<Parse::RecDescent> grammar for C<C> is fledgling. It'll get better. For now be careful and examine the generated code when things don't work. Also, using "C<perl -MInline=INFO ...>" will give you useful information.

=item 2

C<Inline> doesn't yet support custom typemapping. To pass anything beyond basic C types, use the type C<SV*> and do your own conversions "inline". See L<Inline::C::Tutorial> for more information on programming with C.

=item 3

While C<Inline> does attempt to clean up after itself, there is currently no functionality to remove a shared object when a new version is compiled. This shouldn't be hard to do, but I want to think about it a little more. 

=item 4

The compile time using Visual C++ on MSWin32 seems to be much slower in my tests so far. During this time, your script will seem to hang. Just be patient. After compilation, the execution time is comparable.

=back

=head1 AUTHOR

Brian Ingerson <INGY@cpan.org>

=head1 COPYRIGHT

Copyright (c) 2000, Brian Ingerson. All Rights Reserved.  This module is free software. It may be used, redistributed and/or modified under the terms of the Perl Artistic License.

(see http://www.perl.com/perl/misc/Artistic.html)

=cut
